    //Реализация алгоритма Форда-Фалкерсона
    #include <iostream>
    #include <vector>
    #include <queue>//очередь
    #include <climits>//библиотека для определния пределов целочисленных типов (INT_MAX)
    #include "L614_242.hpp"

    //поиск в ширину
    //Функция bfs выполняет обход в ширину для поиска увеличивающего пути от source до sink.
    int bfs(const FlowGraph& g, int source, int sink, std::vector<int>& parent) {
        //принимает граф g, вершину источника,
        //вершину стока и вектор parent, который будет хранить пути.
        std::fill(parent.begin(), parent.end(), -1);//Инициализируем parent значениями -1, чтобы обозначить, что все вершины изначально не посещены.
        //Устанавливаем parent[source] в -2, чтобы отметить, что это источник.
        parent[source] = -2; // Отметим источник
        std::queue<std::pair<int, int>> q;
        q.emplace(source, INT_MAX);
        //Создаём очередь q, в которую будем добавлять пары вершин и минимальный поток.
        //  Начинаем с источника, при этом минимальный поток инициализируется INT_MAX.

        while (!q.empty()) {//Запускаем цикл, пока очередь не пуста.
            int current = q.front().first;//Берём из очереди первую пару: current — текущая вершина, flow — минимальный доступный поток.
            int flow = q.front().second;//Перебираем все рёбра, исходящие из текущей вершины.
            q.pop();

            for (const Edge& edge : g.getAdj(current)) {
                if (parent[edge.to] == -1 && edge.flow < edge.capacity) {
                    //Проверяем, не посещена ли вершина edge.to и есть ли в ребре доступный объём
                    //(т.е. текущий поток меньше максимальной пропускной способности).
                    parent[edge.to] = current;
                    //Устанавливаем родителя для вершины edge.to — это текущая вершина.
                    int new_flow = std::min(flow, edge.capacity - edge.flow);
                    //Рассчитываем новый поток, который может пройти через ребро, как минимум между текущим потоком и доступным объёмом ребра.
                    if (edge.to == sink) {
                        return new_flow; //Если достигли стока, возвращаем найденный поток.
                    }
                    q.emplace(edge.to, new_flow);//Добавляем вершину edge.to и новый поток в очередь для дальнейшей обработки.
                }
            }
        }
        return 0; //Если очередь пустая и не нашли путь до стока, возвращаем 0.
    }

    void augmentPath(FlowGraph& g, int source, int sink, const std::vector<int>& parent, int flow) {
        //Функция augmentPath увеличивает поток по найденному пути.Она принимает граф g, источник source, сток sink, вектор parent и поток flow.
        int current = sink;
        while (current != source) {
            //Начинаем с вершины стока и движемся к источнику, пока не достигнем его.
            int prev = parent[current];//Запоминаем родителя текущей вершины.
            for (Edge& edge : g.getAdj(prev)) {//Проходим по всем рёбрам, исходящим из prev, и увеличиваем поток для ребра, которое ведёт в current.
                if (edge.to == current) {
                    edge.flow += flow; // Увеличиваем поток
                }
            }
            for (Edge& edge : g.getAdj(current)) {
                if (edge.to == prev) {
                    edge.flow -= flow; // Уменьшаем поток в обратном ребре, чтобы учесть новое состояние графа.
                }
            }
            current = prev;//Переходим к родителю, чтобы продолжить увеличение потока по всему пути
        }
    }
    //Основная Функция по Поиску Потока
    int netflow(FlowGraph& g, int source, int sink) {//Функция netflow — основная, которая запускает алгоритм поиска максимального потока.
        //Она принимает граф g, источник source и сток sink.
        std::vector<int> parent(g.size());//Инициализируем вектор parent размером с количество вершин, чтобы отслеживать пути.
        //Переменная maxFlow для хранения общего потока, и flow для хранения потока в текущем итерации.
        int maxFlow = 0, flow;

        while (true) {//Бесконечный цикл, который будет продолжаться до тех пор, пока находятся увеличивающие пути
            flow = bfs(g, source, sink, parent);//Вызываем bfs для поиска увеличивающего пути. Если поток равен 0, выходим из цикла.
            if (flow == 0) {
                break; // Нет увеличивающего пути
            }
            maxFlow += flow;
            augmentPath(g, source, sink, parent, flow);//Увеличиваем общий поток на найденный и увеличиваем поток по найденному пути.
        }

        return maxFlow;//Возвращаем максимальный поток после завершения алгоритма.
    }

